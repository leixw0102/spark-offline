1.生成卡点对
取一个时段内（如最近一个月）所有的过车数据，按车牌号进行分组，那么每组数据会形成车辆的行驶轨迹。
轨迹数据格式为：(卡点云编号，经过时间，行驶方向，所在车道，速度)，每辆车的轨迹是一条带有地理位置
时间序列
左边矩形代表车辆，右边圆圈序列代表每辆车的行驶轨迹，按时间从小到大排序。每个圆圈代表一条过车记录，
所包含的数据有(卡点云编号，经过时间，行驶方向，所在车道，速度)。圆圈上方的数字代表车辆经过的卡点云
编号。现在按照以下步骤进行操作：对车辆A，经过的卡点序列依次为78，79，252，255，会生成三个卡点对：
(78,79), (79,252), (252,255)，同时可以得到这三个卡点对的旅行时间。对车辆B、C和D，做同样操作，可以
得到如下结果：
卡点对	数量	旅行时间序列
(79,252)	3	56,58,63
(252,10043)	2	123,118
(78,79)	1	43
(252,255)	1	90
(1,2)	1	132
(2,10406)	1	87
(10043,65)	1	45
(65,3)	1	203
(5,79)	1	102

对统计结果按卡点对数量倒序排序，取所有卡点对的前5%（暂定5%，后面可以优化算法）作为卡点关联关系基
础数据，从而可以创建卡点有向图。例如，对上面统计结果取前两个卡点对(79,252)和(252,10043)，那么卡点
关联关系就包括这两个卡点对。同时，可以根据旅行时间序列计算出自由流旅行时间（1-5点）。


1.读取hdfs 文件数据
   过滤掉无牌，00000000，保留当天数据--a

2.以 车牌号-类型为key ,进行group ==>(k,values)---b
3.遍历b :
   对values 进行时间排序
   判断 values 中 i,与i+1的时间差是否《=30分钟
   《=30分钟：对轨迹进行延续
    》30分钟：另外一条轨迹的开始
   将结果放入array
    最终格式  k,array(passtime,cid)
4.保存数据--hdfs:格式k,passtiime-cid`passtime-cid...etc



1.读取3个月的base数据
2.处理数据时间以30分为粒度
  形成格式车牌号，车辆类型，开始时间，结束时间，卡点对--c

3.对c做reduceByKey(_+_)  其中key =c 形成 c,sum（相同记录求和）

4,对sum进行排序
5.取前5个，并保存到hdfs格式：c,sum


导出到Es